

### 学习微前端架构-乾坤

目的：拆分应用，减轻一个庞大应用的压力，从另一个方面将公司所有的系统进行整合，形成一个整体。

微前端出现以前，每个系统都是独立的，用户需要保存不同系统的网址，使用微前端后，记录一个地址就好了。在用户层面进了整合，从开发层面减轻了系统压力。

主应用（不限技术栈）和子应用（目前vite项目的支持度不是很好）

接入案例，参考官网[qiankun](https://qiankun.umijs.org/zh/)

首先需要搭建子应用，以vue2项目和react项目为例，主应用使用vue3



#### 微应用实现

需要实现两个函数`registerMicroApps`和`start `，`registerMicroApps`用来实现注册子应用。

**实现入口**

在主应用下新建micro-fe目录，新建index.js文件，需要导出两个方法

```js
import {rewriteRouter} from "./rewrite-router.js"
import {handleRouter} from "./handle-router.js"

let apps = []
export getApps = ()=>{return apps}
export const  registerMicroApps = (_apps)=>{
    apps = _apps
}

export const start = ()=>{
    rewriteRouter(apps)
    //可能会出现直接打开子路由的情况，因此默认要执行一次处理路由的方法
    handleRouter()
}
```

新建rewrite-router.js文件，实现重写路由方法

微应用内部是通过监听路由的变化实现的，hash模式，通过重写`onHashChange`方法监听，history模式通过重写改变history方法的方式实现。我们可以在路由改变时使用当前路径和微应用提供的activeRule进行匹配，匹配上之后根据提供的`entry`加载子应用即可，再将加载到的资源追加到主应用提供的容器中进行展示。

**实现路由监听**

```js
import {handleRouter} from "./handle-router.js"
export const rewriteRouter = (apps)=>{
    //监听replaceState方法和pushState方法，为了不直接改变原生方法，我们使用apply实现重写这些方法
    const _replaceState = window.history.replaceState
    window.history.replaceState = (...args)=>{
        _replaceState.apply(window.history,args)
        //下一步，加载子应用
        handleRouter()
    }
   	
    const _pushState = window.history.pushState
    window.history.pushState = (...args)=>{
        __pushState.apply(window.history,args)
        handleRouter()
    }  
}
```

**实现路由匹配，子应用加载**

新建handle-router.js

```js
import {getApps} from "./index.js"
export const handleRouter = ()=>{
    //根据当前地址匹配子应用
    const pathname = window.location.pathname
    const app = getApps() && getApps().find((item)=>{
        return pathname.startsWith(item.activeRule)
    })
    if(!app) return
    //有匹配的，进行渲染
    const container = document.querySelector("#subapp-container")
    //加载匹配到的子应用资源
    const response = await fetch(app.entry);
    const body = await response.text();
    //将加载到的资源追加到主应用提供的容器中
    container.innerHTML = body
}
```

发现，路由已经切换了，内容也插入了但是页面并没有改变，是因为所有的资源都在app.js，运行app.js才会展示页面，因此需要获取到script标签中的资源

![1667107193439](C:\Users\shzto\AppData\Local\Temp\1667107193439.png)

加载app.js资源handle-router.js

```js
import {getApps} from "./index.js"
import {importHtml}from "import-html.js" 
export const handleRouter = async()=>{
    //根据当前地址匹配子应用
    const pathname = window.location.pathname
    const app = getApps() && getApps().find((item)=>{
        return pathname.startsWith(item.activeRule)
    })
    if(!app) return
    //有匹配的，进行渲染
    const container = document.querySelector("#subapp-container")
    //加载匹配到的子应用资源
    const {template,execScript} = await importHtml(app.entry)
    //执行获取到的js资源,拿到子应用的mount、unmount、bootstrap方法
    const remoteApp = await execScript()
    app.bootstrap = result.bootstrap;
    app.mount = result.mount;
    app.unmount = result.unmount;
    //渲染页面，调用bootstrap和mount方法
    await bootstrap(app)
    await mount(app)   
}

async function bootstrap(app) {
    //执行子应用的bootstrap方法，传入app对象，app里包含的属性{name，entry，container，activeRule，bootstrap，mount，unmount}，传入子应用里面，如果子应用里找到container了，挂载的时候挂载到指定页面
  app.bootstrap && app.bootstrap(app);
}

async function mount(app) {
  app.mount &&
    app.mount({
      container: document.querySelector(app.container),
    });
}

async function unmount() {}
```

Import-html.js

```js
// import importHTML from "import-html-entry";
import { fetchResource } from "./fetchResource";
//解析html模块代码
export const importHtml = async (url) => {
  //解析html文件，加载app.js文件
  //截取script标签
  const html = await fetchResource(url);
  const template = document.createElement("div");
  template.innerHTML = html;

  //查找所有script标签
  const scripts = template.querySelectorAll("script");
  async function getExternalScripts() {
    return Promise.all(
      Array.from(scripts).map((script) => {
        const src = script.getAttribute("src");
        if (!src) {
          return Promise.resolve(script.innerHTML);
        } else {
          //拼接src属性
          return fetchResource(src.startsWith("http") ? "src" : `${url}${src}`);
        }
      })
    );
  }
  //执行scripts
  async function execScript() {
    const scripts = await getExternalScripts();
    //console.log(scripts)
    //手动构建commonjs规范
    const module = { exports: {} };
    const exports = module.exports;
    //控制子应用挂载问题
    window.__POWERED_BY_QIANKUN__ = true;
    window.__POWERED_BY_QIANKUN__ = app.entry + "/";
    //子应用样式隔离问题，通过打包library库实现umd格式iife
    //umd兼容commonjs amd和es module
    scripts.forEach((code) => {
      eval(code);
    });
    return module.exports;
  }
  return { template, getExternalScripts, execScript };
};
```

![1667108558375](C:\Users\shzto\AppData\Local\Temp\1667108558375.png)这是请求子应用里面script中的资源，将获取到的代码暴露出一个模块，

mount加载的时候，props为空，render时，挂载到的dom是#app，而不是container.querySelector("#app")，从而导致主应用的页面会被替换掉

```js
function render(props = {}) {
  const { container } = props;
  router = route;
  instance = new Vue({
    router,
    render: h => h(App)
  }).$mount(container ? container.querySelector("#app") : "#app");
}
if (!window.__POWERED_BY_QIANKUN__) {
  render({});
}

export async function mount(props) {
  console.log("[vue] props from main framework", props);
  render(props);
}
```

使用umd打包格式解决，[参考](https://blog.csdn.net/SeriousLose/article/details/117996437)

新建import-html.js

```js
export const importHtml =async (url)=>{
    const html = await fetchResource(url)
    const template = document.createElement("div");
    template.innerHTML = html;
    
    //获取所有的script标签
}
```

![1667120092557](C:\Users\shzto\AppData\Local\Temp\1667120092557.png)

问题：点击切换之后发现之前的菜单还在，需要卸载之后再挂载，怎么知道之前的路由是哪个进行卸载，需要自己进行记录

rewriteRouter.js

```js
import { handleRouter } from "./handleRouter";

export const getPrevRoute = () => {
  return _prevRouter;
};
export const getNextRoute = () => {
  return _nextRouter;
};
//记录前一个路由
let _prevRouter = null;
//记录当前路由
let _activeRouter = window.location.pathname;
export const rewriteRouter = () => {
  const _replaceState = window.history.replaceState;
  window.history.replaceState = (...args) => {
    _prevRouter = window.location.pathname;
    _replaceState.apply(window.history, args);
    _activeRouter = window.location.pathname;
    handleRouter();
  };

  const _pushState = window.history.pushState;
  window.history.pushState = (...args) => {
    _prevRouter = window.location.pathname;
    _pushState.apply(window.history, args);
    _activeRouter = window.location.pathname;
    handleRouter();
  };
};
```

解决图片加载路径问题:

接入微应用时，引入的public-path.js文件

```js
if (window.__POWERED_BY_QIANKUN__) {
    //修改webpack publicPath路径
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}
```

在importHtml.js中修改`__INJECTED_PUBLIC_PATH_BY_QIANKUN__`的值

```js
async function execScript() {
    const scripts = await getExternalScripts();
    //手动构建commonjs规范
    const module = { exports: {} };
    const exports = module.exports;
    //控制子应用挂载问题
    window.__POWERED_BY_QIANKUN__ = true;
    //重新指定PublicPath
    window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ = url + "/";
    //子应用样式隔离问题，通过打包library库实现umd格式iife
    //umd兼容commonjs amd和es module
    scripts.forEach((code) => {
      eval(code);
    });

    return module.exports;
    // return window["app-vue2-app"];
  }
```

此时发现已经可正常加载图片了。

![1667140608145](C:\Users\shzto\AppData\Local\Temp\1667140608145.png)

另一个问题：react应用接入微应用怎么解决打包格式问题

使用：`@rescripts/cli `插件或者`react-app-rewired `重写webpack配置文件解决

**主应用**

[主应用git](https://gitee.com/lipengzhou/micro-main/blob/master/src/main.js)

主应用代码，注册子应用：

```js
import { registerMicroApps, start } from "qiankun";
//注册子应用,当匹配到activeRule的时候，请求获取entry资源，渲染到container中
registerMicroApps(
  {
    name: "app-react",
    entry: "//localhost:3000", //子应用html入口
    container: "#subapp-container", //渲染到哪里
    activeRule: "/subapp/app-react", //路由匹配规则
  }
);
```

布局组件中main部分设置两个出口，一个主应用路由出口，使用`route-view`，另一个是子应用路由出口，使用`<div id="aubapp-title"> </div>`一个html标签

**子应用**

注册三个必要的声明周期函数，需要返回promise

```js
//渲染之前
export async function bootstrap() {
  console.log('[vue] vue app bootstraped');
}
//渲染函数
export async function mount(props) {
  console.log('[vue] props from main framework', props);
  render(props);
}
//卸载函数
export async function unmount() {
  instance.$destroy();
  instance.$el.innerHTML = '';
  instance = null;
  router = null;
}
```

通过import-html-entry解析出scripts，执行scripts

umd兼容commonjs amd和es module 



* vue3开发阶段eslint代码编译问题，编译插件问题
* vue3引入路由，使用函数方式引入不是直接引入一个对象

```js
import { createRouter, createWebHashHistory } from "vue-router";
```



样式隔离怎么做到的



**js隔离机制**

SnapshotSandbox、LegacySandbox、ProxySandbox三种不同的隔离机制 

快照沙箱、支持单应用的代理沙箱、支持多应用的代理沙箱 

快照沙箱需要遍历window上的所有属性，性能较差

支持单应用的代理沙箱：会污染全局变量，仅允许同时运行一个微应用

支持多应用的代理沙箱 ：支持一个页面运行多个微应用



因为**single-spa**中所谓的注册微应用，**本质上就是获取微应用暴露的相关生命周期方法，在后续程序运转过程中，通过控制这些生命周期方法，进而实现对微应用的控制** 

------

reflect和proxy

proxy代理陷阱，reflect只是一种元编程的操作，和通过对象.属性名访问的值是一样的，通过reflect.get(obj,'name')同样可以获取到对象的属性

设计目的：为操作对象，而提供的新API

- 重新Object上的方法
- 将之前Object上的方法的返回变得合理，定义对象上不能修改的属性会报错，reflect返回true or false来标识
- 让Object操作变成函数行为，delete操作符，prop in obj，现在使用reflect.delete,reflect.has



------

registerMicroApps方法

single-spa中注册的微应用，本质上就是获取微应用相关的生命周期方法，通过控制生命周期方法实现对微应用的控制.

```js
export const registerMicroApps = (apps) => {
  //过滤没有注册过的应用
  const unregisteredApps = apps.filter(
    (app) => !microApps.some((registeredApp) => registeredApp.name === app.name)
  );

  //初始化整合没有注册的和已经注册的应用
  microApps = [...microApps, ...unregisteredApps];
  unregisteredApps.forEach((app) => {
    const { name, activeRule, load = noop } = app;
    //注册应用
    registerApplication({
      name,
      app: async () => {
        const { mount, ...otherMicroAppConfigs } = (
          await loadApp({ name, props, ...appConfig })
        )();
      },
    });
  });
};
```

parcelConfig 返回的内容{name,bootstrap,mount,unmount}就是single-spa需要微应用暴露的生命周期函数。后续通过执行对应生命周期函数而控制微应用



**沙箱容器：**

```js
function createSandboxContainer (){
    return {
        instance:sandbox,
        async mount(){},
        async unmount(){}
    } 
}
```

patchAtBootstrapping 根据不同类型的沙箱，执行后以数组的形式返回执行结果

```js
function patchAtBootstrapping(){
    patchersInSandbox = {
        LegacyProxy:patchLooseSandbox(),
        Proxy:patchStrictSandbox(),
        Snapshot:patchLooseSandbox()
    }
    return patchersInSandbox[sandbox.type]?.map((pach)=>patch())
}
```

patchStrictSandbox

```js
function patchStrictSandbox(
  appName: string,
  appWrapperGetter: () => HTMLElement | ShadowRoot,
  proxy: Window,
  mounting = true,
  scopedCSS = false,
  excludeAssetFilter?: CallableFunction,
  speedySandbox = false,
): Freer {
    //根据sandbox实例返回配置项，从入口函数的传参可以看出来proxy是sandox的代理对象   patchStrictSandbox(appName, elementGetter, sandbox.proxy, false, scopedCSS, excludeAssetFilter, speedySandBox),
    let containerConfig = proxyAttachContainerConfigMap.get(proxy);
    if(containerConfig){
        //...
        //为什么要设置缓存？patchDocumentCreateElement的时候用到了，
        proxyAttachContainerConfigMap.set(proxy, containerConfig);
    }
    //缓存所有的动态style样式
    const { dynamicStyleSheetElements } = containerConfig;
    const unpatchDocumentCreate = patchDocumentCreateElement();
    return function free(){
        return funcion rebuild(){
            
        }
    }
}
```

patchDocumentCreateElement 

```js
function patchDocumentCreateElement(){
    const docCreateElementFnBeforeOverwrite = docCreatePatchedMap.get(document.createElement);
    if(!docCreateElementFnBeforeOverwrite){
        //...重写Document.cretaeElement方法
        //判断是否是link,script和style标签
        if(isHijackingTag(tagName)){
            const {currentRunningSandboxProxy} = getCurrentRunningApp() || []
            if(currentRunningSandboxProxy){
                const proxyContainerConfig = proxyAttachContainerMap.get(currentRunningSandboxProxy)
                if(proxyContainerConfig){
                    elementAttachContainerConfigMap.set(element,proxyContainerConfig)
                }
            }
        }
    }
}
```

#### **乾坤资源加载机制**

通过import-html-entry请求资源

主要过程

```js
 const { template, execScripts, assetPublicPath } = await importEntry(entry, importEntryOpts);
```

加载entry方法

```js
function importEntry(entry,opts={}){
    const {fetch = defaultFect,getTemplate} = opts	const {
		fetch = defaultFetch,
		getTemplate = defaultGetTemplate,
		postProcessTemplate,
	} = opts;
    //entry不存在，提示报错
    if(!entry) return
    //针对单页应用的情况
    if(typeof entry === "string"){
        //加载html
        return importHTML(entry,{fetch,getPublicPath,getTemplate,postProcessTemplate})
    }
    //针对子应用是多出口的情况，加载多个入口文件
    	if (Array.isArray(entry.scripts) || Array.isArray(entry.styles)) {
		const { scripts = [], styles = [], html = "" } = entry;
		//1.处理style
		//2.处理scripts
		//3.模板文件，处理逻辑和一个入口的子应用一样的，返回内容也是一样的
		return getEmbedHTML(
			getTemplate(
				getHTMLWithScriptPlaceholder(getHTMLWithStylePlaceholder(html))
			),
			styles,
			{ fetch }
		).then((embedHTML) => ({
			template: embedHTML,
			assetPublicPath: getPublicPath(entry),
			getExternalScripts: () => getExternalScripts(scripts, fetch),
			getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),
			execScripts: (proxy, strictGlobal, opts = {}) => {
				if (!scripts.length) {
					return Promise.resolve();
				}
				return execScripts(scripts[scripts.length - 1], scripts, proxy, {
					fetch,
					strictGlobal,
					...opts,
				});
			},
		}));
	} else {
		throw new SyntaxError("entry scripts or styles should be array!");
	}
    
}
```

importHTML 

```js
export default function importHTML(url, opts = {}) {
	let fetch = defaultFetch;
	let autoDecodeResponse = false;
	let getPublicPath = defaultGetPublicPath;
	let getTemplate = defaultGetTemplate;
	const { postProcessTemplate } = opts;
	//...处理fetch逻辑
	return (
		embedHTMLCache[url] ||
		(embedHTMLCache[url] = fetch(url)
			.then((response) => readResAsString(response, autoDecodeResponse))
			.then((html) => {
				const assetPublicPath = getPublicPath(url);
            //根据模板字符串和publicPath解析出模板，js脚本和style
				const { template, scripts, entry, styles } = processTpl(
					getTemplate(html),
					assetPublicPath,
					postProcessTemplate
				);

            //将获取到的模板文件，scripts，styles以对象的方式返回
				return getEmbedHTML(template, styles, { fetch }).then((embedHTML) => ({
					template: embedHTML,
					assetPublicPath,
					getExternalScripts: () => getExternalScripts(scripts, fetch),
					getExternalStyleSheets: () => getExternalStyleSheets(styles, fetch),
					execScripts: (proxy, strictGlobal, opts = {}) => {
						return execScripts(entry, scripts, proxy, {
							fetch,
							strictGlobal,
							...opts,
						});
					},
				}));
			}))
	);
}
```

readResAsString函数，处理fetch的请求结果，将结果转换成string

processTpl 函数，

```js
export default function processTpl(tpl, baseURI, postProcessTemplate) {
	let scripts = [];
	const styles = [];
	let entry = null;
	const moduleSupport = isModuleScriptSupported();

	const template = tpl
    //...省略
	//1.去掉掉注释代码
	//2.处理link标签，解析远程样式
    //3.处理行内样式
	//4.处理script标签

	//返回所有执行的script脚本数组，模板、style标签
	let tplResult = {
		template,
		scripts,
		styles,
		// set the last script as entry if have not set
		entry: entry || scripts[scripts.length - 1],
	};

	return tplResult;
}
```

测试processTpl ，开启一个项目，使用fetch获取请求到的资源，然后调用processTpl方法,其中正则表达式`s`修饰符是es6的语法，如果使用的是vue-cli创建的vue2项目，编译会报错，提示内容是` Invalid regular expression: invalid group`,需要使用`@babel/preset-env `解决，安装 `npm install -D @babel/core @babel/preset-env babel-loader @babel/plugin-transform-runtime`  

.babelrc文件配置

```js
{
  "presets": ["@babel/preset-env"],
  "plugins": [
    "@babel/plugin-transform-runtime",
    "@babel/plugin-proposal-optional-chaining"
  ],
  "env": {
    "esm": {
      "presets": [
        [
          "@babel/preset-env",
          {
            "modules": false
          }
        ]
      ],
      "plugins": [
        [
          "@babel/plugin-transform-runtime",
          {
            "useESModules": true
          }
        ],
        "@babel/plugin-proposal-optional-chaining"
      ]
    }
  }
}

```

调用processTpl测试代码：

```js
import processTpl from "./import-html/process-tpl.js";
let template = "";
const url = "http://localhost:8080";

fetch(url)
  .then(response => {
    response.text().then(res => {
      const { template, scripts, entry, styles } = processTpl(res, url);
      console.log(template, scripts, entry, styles);
    });
  })
  .catch(err => {
    console.log(err);
  });
```

分别打印的`template, scripts, entry, styles`内容如下，`template`返回的模板文件，`scripts`中返回的js脚本，包含在模板文件中中的js代码和远程加载的js文件，`styles`中返回所有使用Link标签加载的css文件，可以看出来内置的style标签里面的内容和行内样式都没有打印出来，style处理只针对的是远程加的css文件。

为什么不用单独解析行内样式和内嵌样式？

我想应该是这些样式不需要处理，可以直接在页面加载的时候直接及逆行渲染，如果引用的是外联样式，可以发现打包好的模板文件把引入的代码给注释掉了，在`getEmbedHTML `可以看到

![1667823480447](C:\Users\shzto\AppData\Local\Temp\1667823480447.png)

getEmbedHTML ,opts是importHTML 中传的fetch方法，这个方法的作用是返回style标签替换后的模板文件

```js
function getEmbedHTML(template, styles, opts = {}) {
	const { fetch = defaultFetch } = opts;
	let embedHTML = template;
	//获取远程的style属性
	return getExternalStyleSheets(styles, fetch).then((styleSheets) => {
		embedHTML = styles.reduce((html, styleSrc, i) => {
			//将远程加载的css文件使用内嵌的方式加入到模板里面
			html = html.replace(
				genLinkReplaceSymbol(styleSrc),
				isInlineCode(styleSrc)
					? `${styleSrc}`
					: `<style>/* ${styleSrc} */${styleSheets[i]}</style>`
			);
			return html;
		}, embedHTML);
		return embedHTML;
	});
}
```

回到importHTML方法，可以看到返回结果就是模板文件，scripts，styles

再往上返回到importEntry方法，可以看到返回结果是importHTML方法的执行结果，也就是将模板文件，scripts，styles这些内容返回。

看一下execScripts 方法

```js
export function execScripts(entry, scripts, proxy = window, opts = {}) {
	const {
		fetch = defaultFetch,
		strictGlobal = false,
		success,
		error = () => {},
		beforeExec = () => {},
		afterExec = () => {},
		scopedGlobalVariables = [],
	} = opts;
    return getExternalScripts(scripts,fetch,error).then((scriptsText)=>{
        const geval = (scriptSrc,inlineScript)=>{
			const rawCode = beforeExec(inlineScript, scriptSrc) || inlineScript;
			//返回的代码内容为一个自执行函数
			const code = getExecutableScript(scriptSrc, rawCode, {
				proxy,
				strictGlobal,
				scopedGlobalVariables,
			});

			evalCode(scriptSrc, code);

			afterExec(inlineScript, scriptSrc);
        }
        
        function exec(scriptSrc, inlineScript, resolve){
            if(scriptSrc === entry){
               geval(scriptSrc,inlineScript)
                const exports = proxy[getGlobalProp(strictGlobal ? proxy : window)] || {}
                resolve(exports)
            }else{
                if(typeof inlineScript === "string"){
                    geval(scriptSrc,inlineScript)
                }else{
                    inlineScript.async && inlineScript?.content.then((downloadedScriptText)=>{
                    geval(inlineScript.src,downloadedScriptText)
                })
                }
            }
        }
        function schedule(i, resolvePromise) {
           			//循环执行scripts
			if (i < scripts.length) {
				const scriptSrc = scripts[i];
				const inlineScript = scriptsText[i];

				exec(scriptSrc, inlineScript, resolvePromise);
				// resolve the promise while the last script executed and entry not provided
				if (!entry && i === scripts.length - 1) {
					resolvePromise();
				} else {
					schedule(i + 1, resolvePromise);
				}
			} 
        }
        return new Promise((resolve)=>schedule(0,success||resolve))
    })
}
```

getExternalScripts函数,如果script是内嵌代码，将去掉标签后的可执行代码返回，具体表现在`getInlineCode `这个函数，从getExternalScripts函数的执行结果也可以看出来

如果是带src属性的js代码，则调用`fetchScripts`函数获取js代码，获取到的代码本身就是可执行的代码。

getExternalScripts执行完后调用`schedule `函数，看schedule 函数的代码

```js
function getExternalScripts( 
	scripts,
    fetch = defaultFetch,
    errorCallback = () => {}){
        return Promise.all(scripts.map(script)=>{
            if(typeof script === "string"){
                 //内嵌js代码
                if(isInlineCode(script)){
                    //返回可执行的代码
                    return getInLineCode(script)
                }else{
                    //加载远程脚本代码
                    return fetchScript(script)
                }
            }
        })
}
```

schedule 函数执行过程见下图

```js
    function schedule(i, resolvePromise) {
      //循环执行scripts
      if (i < scripts.length) {
        const scriptSrc = scripts[i];
        const inlineScript = scriptsText[i];
        exec(scriptSrc, inlineScript, resolvePromise);
        // resolve the promise while the last script executed and entry not provided
        if (!entry && i === scripts.length - 1) {
          resolvePromise();
        } else {
          schedule(i + 1, resolvePromise);
        }
      }
    }
```

![1667890347322](C:\Users\shzto\AppData\Local\Temp\1667890347322.png)

exec函数

```js
function exec(scriptSrc, inlineScript, resolve){
 	//...省略    主要是执行geval方法      
}
//geval函数
const geval = (scriptSrc, inlineScript) => {
      const rawCode = beforeExec(inlineScript, scriptSrc) || inlineScript;
      //返回的代码内容为一个自执行函数
      const code = getExecutableScript(scriptSrc, rawCode, {
        proxy,
        strictGlobal,
        scopedGlobalVariables
      });

      evalCode(scriptSrc, code);

      afterExec(inlineScript, scriptSrc);
    };
```

getExecutableScript函数返回结果，可以看到是将解析出来的代码改为一个执行函数，至于为什么要传proxy而不直接是window，是为了改变this指向，在当前我的里面proxy指向的就是window

![1667891388709](C:\Users\shzto\AppData\Local\Temp\1667891388709.png)

getExecutableScript函数，直接看返回结果即可，接下来就是执行evalCode 方法，

```js
function getExecutableScript(scriptSrc, scriptText, opts = {}) {
  const { proxy, strictGlobal, scopedGlobalVariables = [] } = opts;
  return strictGlobal
    ? scopedGlobalVariableFnParameters
      ? `;(function(){with(window.proxy){(function(${scopedGlobalVariableFnParameters}){;${scriptText}\n${sourceUrl}}).bind(window.proxy)(${scopedGlobalVariableFnParameters})}})();`
      : `;(function(window, self, globalThis){with(window){;${scriptText}\n${sourceUrl}}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`
    : `;(function(window, self, globalThis){;${scriptText}\n${sourceUrl}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;
}
```

evalCode 函数

```js
export function evalCode(scriptSrc, code) {
	const key = scriptSrc;
    //对需要执行的script代码进行缓存，防止重复执行
	if (!evalCache[key]) {
        //已经构建了一个自执行函数了，为什么还要重新构建呢？这里还不是很理解
		const functionWrappedCode = `(function(){${code}})`;
        //间接调用eval函数，返回一个可以计算的值
		evalCache[key] = (0, eval)(functionWrappedCode);
	}
	const evalFunc = evalCache[key];
    //执行获取到的js代码，构建一个自执行函数，不用使用eval，看源码上面配置的使用with，还有待踩的坑，就不关注了
	evalFunc.call(window);
}
```

**(0,eval)这行代码怎么理解？**参考下面两篇文章

[(0, eval)(functionWrappedCode)](https://www.cnblogs.com/qianlegeqian/p/3950044.html) 

[eval的一些理解](https://www.oschina.net/translate/global-eval-what-are-the-options)

functionWrappedCode的结果，目前还不是很理解为什么要重新构建一个function，为了防止重写this的指向吗？

![1667893021581](C:\Users\shzto\AppData\Local\Temp\1667893021581.png)

至此加载的模板中的js代码执行完毕（包含远程的和内嵌的代码），控制台打印出123，说明我们已经加载了打包好的资源并且执行了。因为单页应用的渲染和事件执行都在打包好的入口文件里面即app.js，所有执行了app.js中的代码后就可以跳转到我们的子应用了。



requestIdleCallback 插入一个函数，这个函数将再浏览器空闲时期被调用

#### css隔离机制

![乾坤css隔离机制.jpg](https://upload-images.jianshu.io/upload_images/10131721-a42a92973bf25852.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

[乾坤解决样式隔离的几种方法：](https://qiankun.umijs.org/zh/api#startopts)

*   确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离
```
start({sandbox : true})//沙箱隔离，
```
判断沙箱隔离的方法，发现直接设置sandbox=true是不行的，需要使用`experimentalStyleIsolation`这个属性配置。
```
export function isEnableScopedCSS(sandbox: FrameworkConfiguration['sandbox']) {
  if (typeof sandbox !== 'object') {
    return false;
  }
  if (sandbox.strictStyleIsolation) {
    return false;
  }
  return !!sandbox.experimentalStyleIsolation;
}
```
* `{ strictStyleIsolation: true } `开启严格的样式隔离模式 ,shawod dom'
```
start({shadow:{ strictStyleIsolation: true }})
```
直观的可以看到，子应用的代码不是正常的dom,上面显示的shadow-root，先不管shadow-root是什么，接着往下看
![image.png](https://upload-images.jianshu.io/upload_images/10131721-407c85abfec1402d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* `experimentalStyleIsolation  `给子应用加上自定义的data-xxx属性，相当于vue中我们通常使用的scoped，从生成的代码中可以看出来
  ![1668608526445.png](https://upload-images.jianshu.io/upload_images/10131721-c23f2e2d1f681e93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
##### 在主应用中，通过配置`sandbox`做到样式隔离
```
start({ sandbox: { strictStyleIsolation: true } });
```
在start得时候配置得参数，但是只有等到start函数里面 `frameworkStartedDefer.resolve()` 之后才能往下执行.
`registerMicroApps`只是准备好注册的应用配置信息，只有等调用了start方法之后，才会走`registerApplication`相关逻辑，`registerApplication`是`single-spa`中的一个主要的方法，乾坤实现微应用也主要用的是`single-spa`这个库

start 方法
```
export function start(opts: FrameworkConfiguration = {}) {
  frameworkConfiguration = { prefetch: true, singular: true, sandbox: true, ...opts };
  startSingleSpa({ urlRerouteOnly });
  started = true;
    //执行loadApp相关逻辑
  frameworkStartedDefer.resolve();
}
```
修改appid得代码是在single-spa中还是qiankun中得？->qiankun，在处理模板的时候使用`shadow dom`实现的

loadApp中使用严格样式隔离的代码
```
export async function loadApp<T extends ObjectType>(
  app: LoadableApp<T>,
  configuration: FrameworkConfiguration = {},
  lifeCycles?: FrameworkLifeCycles<T>,
): Promise<ParcelConfigObjectGetter> {
      const strictStyleIsolation = typeof sandbox === 'object' && !!sandbox.strictStyleIsolation;
      let initialAppWrapperElement: HTMLElement | null = createElement(
        appContent,
        strictStyleIsolation,
        scopedCSS,
        appInstanceId,
      );
}
```
createElement方法相关代码，我们在`start`方法中配置了`strictStyleIsolation`严格样式模式，因此会走到`strictStyleIsolation`判断相关逻辑里面，从这里面就可以看到创建`shadow dom`相关代码
```
function createElement(
  appContent: string,
  strictStyleIsolation: boolean,
  scopedCSS: boolean,
  appInstanceId: string,
): HTMLElement {
  const containerElement = document.createElement('div');
  containerElement.innerHTML = appContent;
  // appContent always wrapped with a singular div
  const appElement = containerElement.firstChild as HTMLElement;
     //绝对样式隔离相关代码
  if (strictStyleIsolation) {
      //使用shadow做样式隔离
      const { innerHTML } = appElement;
      appElement.innerHTML = '';
      let shadow: ShadowRoot;

      if (appElement.attachShadow) {
        shadow = appElement.attachShadow({ mode: 'open' });
      } else {
        // createShadowRoot was proposed in initial spec, which has then been deprecated
        shadow = (appElement as any).createShadowRoot();
      }
      shadow.innerHTML = innerHTML;

  }

 //...scopedCSS判断相关代码

  return appElement;
}
```
##### 使用`scopedCss`做到样式隔离
前面入口出的逻辑和`shadow`大致相同，scopedCss代码也很好理解，就是先查找要添加的应用是否有相应的属性，没有的话给子应用容器添加一个属性。然后遍历每个style标签，在每个style标签代码前面增加属性选择符，通过属性选择符+样式来确保样式不被重写

```
  if (scopedCSS) {
    const attr = appElement.getAttribute(css.QiankunCSSRewriteAttr);
    if (!attr) {
        //这边attr生成的属性：data-qiankun :vue2App
      appElement.setAttribute(css.QiankunCSSRewriteAttr, appInstanceId);
    }

    const styleNodes = appElement.querySelectorAll('style') || [];
    forEach(styleNodes, (stylesheetElement: HTMLStyleElement) => {
      css.process(appElement!, stylesheetElement, appInstanceId);
    });
  }
```
css.process方法
```
export const process = (
  appWrapper: HTMLElement,
  stylesheetElement: HTMLStyleElement | HTMLLinkElement,
  appName: string,
): void => {
  // lazy singleton pattern
  if (!processor) {
    processor = new ScopedCSS();
  }
  const mountDOM = appWrapper;
  if (!mountDOM) {
    return;
  }
  const tag = (mountDOM.tagName || '').toLowerCase();

  if (tag && stylesheetElement.tagName === 'STYLE') {
      //生成前缀
    const prefix = `${tag}[${QiankunCSSRewriteAttr}="${appName}"]`;
    processor.process(stylesheetElement, prefix);
  }
};
```
[什么是shadow dom？](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM)

可以将标记结构，样式和行为隐藏起来，和页面上其他代码相隔离。

shadow dom的一个demo:
```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style>
    h1 {
      color: red;
    }
  </style>
  <body>
    <h1>hello 这个主页中的内容</h1>
    <div id="box"></div>
  </body>

  <script>
    window.onload = function () {
      let box = document.getElementById("box");
      //开启shadow dom
      box.attachShadow({ mode: "open" });
      let shadow = box.shadowRoot;
      var h1 = document.createElement("h1");
      h1.innerHTML = "world 这是shaow dom中的内容";
      var style = document.createElement("style");
      style.textContent = `h1{color:green}`;
      shadow.appendChild(style);
      shadow.appendChild(h1);
    };
  </script>
</html>

```

![image.png](https://upload-images.jianshu.io/upload_images/10131721-7da26a004380e37f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### js隔离机制

依旧从loadApp函数入手

```js
export async function loadApp<T extends ObjectType>(
  app: LoadableApp<T>,
  configuration: FrameworkConfiguration = {},
  lifeCycles?: FrameworkLifeCycles<T>,
): Promise<ParcelConfigObjectGetter> {
      const {
        singular = false,
        sandbox = true,
        excludeAssetFilter,
        globalContext = window,
        ...importEntryOpts
      } = configuration;
    if (sandbox) {
        sandboxContainer = createSandboxContainer(
          appInstanceId,
          // FIXME should use a strict sandbox logic while remount, see https://github.com/umijs/qiankun/issues/518
          initialAppWrapperGetter,
          scopedCSS,
          useLooseSandbox,
          excludeAssetFilter,
          global,
          speedySandbox,
        );
        // 用沙箱的代理对象作为接下来使用的全局对象
        global = sandboxContainer.instance.proxy as typeof window;
        mountSandbox = sandboxContainer.mount;
        unmountSandbox = sandboxContainer.unmount;
      }`
}
```

createSandboxContainer方法，创建沙箱容器，根据浏览器环境判断和配置项决定使用哪种沙箱模式，支持`proxy`的浏览器，如果没有明确配置使用单应用沙箱则使用`ProxySandbox`

```js
export function createSandboxContainer(
  appName: string,
  elementGetter: () => HTMLElement | ShadowRoot,
  scopedCSS: boolean,
  useLooseSandbox?: boolean,
  excludeAssetFilter?: (url: string) => boolean,
  globalContext?: typeof window,
  speedySandBox?: boolean,
      ) {
          let sandbox: SandBox;
          //判断浏览器是否支持proxy，如果支持使用proxy，不支持使用快照沙箱
          if (window.Proxy) {
              //LegacySandbox：支持单应用的沙箱，ProxySandbox：支持多应用的沙箱
            sandbox = useLooseSandbox ? new LegacySandbox(appName, globalContext) : new ProxySandbox(appName, globalContext);
          } else {
             //快照沙箱
            sandbox = new SnapshotSandbox(appName);
          }      
          
          return {
              instance:sandbox,
              async mount(){
                  //启动沙箱
                 sandbox.active(); 
                  //...省略一些副作用处理代码
              }，
              async unmount(){
              //关闭沙箱
            	sandbox.inactive();  
          	},
          }
      }
```

等到子应用挂载的时候执行mount方法，此时由于loadApp中使用的是沙箱作为代理对象的，因此执行的mount方法即`createSandboxContainer`的返回结果，在返回的mount函数中启动沙箱。

关于快照沙箱的实现原理可以参考[这篇文章](https://juejin.cn/post/7161056656384917535)，或者直接参考杨艺韬大佬写的[乾坤系列源码的文章](https://juejin.cn/post/7070032850237521956)。

总结来说就是通过active 和Inactive来控制沙箱的生效和失效控制沙箱的启动和关闭，本质还是对window上属性的操作，区别在于直接操作还是通过代理操作。

而单应用和多应用的区别ProxySandbox为支持多应用的代理沙箱 ，LegacySandbox仅仅允许页面同时运行一个微应用 。

关于代理沙箱，单应用和多应用的区别没有看太懂？同样都是使用proxy实现的代理对象也是window为什么proxySandbox就可以实现多应用的隔离呢？

我想应该是因为这段代码，通过`rawObjectDefineProperty`实现对globalContext的深拷贝，这样每次新创建一个`ProxySandbox `实例就会重新初始化一个`fakeWindow` window环境，以此来达到多应用相互隔离的效果。

```js
//Object.defineProperty直接在一个对象上定义一个新属性，或者修改一个已经存在的属性
const rawObjectDefineProperty = Object.defineProperty;
function createFakeWindow(globalContext: Window) {
  // map always has the fastest performance in has check scenario
  // see https://jsperf.com/array-indexof-vs-set-has/23
  const propertiesWithGetter = new Map<PropertyKey, boolean>();
  const fakeWindow = {} as FakeWindow;

  //过滤不可配置的属性，
  Object.getOwnPropertyNames(globalContext)
    .filter((p) => {
      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);
      return !descriptor?.configurable;
    })
    .forEach((p) => {
      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);
      if (descriptor) {
        const hasGetter = Object.prototype.hasOwnProperty.call(descriptor, 'get');
        if (
          p === 'top' ||
          p === 'parent' ||
          p === 'self' ||
          p === 'window' ||
          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))
        ) {
          descriptor.configurable = true;
          if (!hasGetter) {
            descriptor.writable = true;
          }
        }
        if (hasGetter) propertiesWithGetter.set(p, true);
        rawObjectDefineProperty(fakeWindow, p, Object.freeze(descriptor));
      }
    });

  return {
    fakeWindow,
    propertiesWithGetter,
  };
}
```

而`LegacySandbox `是直接操作目标对象的，从这边设置属性的代码可以看出来。

```js
export default class LegacySandbox implements SandBox {
  private setWindowProp(prop: PropertyKey, value: any, toDelete?: boolean) {
    //设置的值不存在，删除window上的属性
    if (value === undefined && toDelete) {
      // eslint-disable-next-line no-param-reassign
      delete (this.globalContext as any)[prop];
    } else if (isPropConfigurable(this.globalContext, prop) && typeof prop !== 'symbol') {
      //window上存在的属性并且可操作，给属性设置值
      Object.defineProperty(this.globalContext, prop, { writable: true, configurable: true });
      // eslint-disable-next-line no-param-reassign
      (this.globalContext as any)[prop] = value;
    }
  }
}
```

### single-spa 

#### 微应用注册流程

registerApplication 配置项中的app需要传是什么东西？

```js
function registerApplication(
  appNameOrConfig,
  appOrLoadApp,
  activeWhen,
  customProps
  ) {
      //...省略一些其他的方法
      //管理应用，添加一些其他配置项
      apps.push(
        assign(
          {
            loadErrorTime: null,
            status: NOT_LOADED,
            parcels: {},
            devtools: {
              overlays: {
                options: {},
                selectors: [],
              },
            },
          },
          registration
        )
      );
      if (isInBrowser) {
        ensureJQuerySupport();
          //主要函数，路由重写
        reroute();
      }    
  }
```

reroute 方法，主要作用存储应用的声明周期方法

```js
function reroute() {
  var pendingPromises =
    arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var eventArguments = arguments.length > 1 ? arguments[1] : undefined;
  if (appChangeUnderway) {
    return new Promise(function (resolve, reject) {
      peopleWaitingOnAppChange.push({
        resolve: resolve,
        reject: reject,
        eventArguments: eventArguments,
      });
    });
  }
  var _getAppChanges = getAppChanges(),
    appsToUnload = _getAppChanges.appsToUnload,
    appsToUnmount = _getAppChanges.appsToUnmount,
    appsToLoad = _getAppChanges.appsToLoad,
    appsToMount = _getAppChanges.appsToMount;
  var appsThatChanged,
    navigationIsCanceled = false,
    oldUrl = currentUrl,
    newUrl = (currentUrl = window.location.href);

  //调用了start方法后为true
  if (isStarted()) {
    appChangeUnderway = true;
    appsThatChanged = appsToUnload.concat(
      appsToLoad,
      appsToUnmount,
      appsToMount
    );
    return performAppChanges();
  } else {
    appsThatChanged = appsToLoad;
      //加载app
    return loadApps();
  }
}
```



performAppChanges方法，使用`customEvent`添加一些自定方法用来监听微应用的一些事件使用，初始化时所有新注册的应用都在`loadThenMountPromises`里面，然后会在`toLoadPromise`方法里面加载微应用信息，接下来看`toLoadPromise`方法

```js
  function performAppChanges() {
    return Promise.resolve().then(function () {
     //...省略一些代码  customEvent注册自定义事件，通常浏览器addEventListener就是用来监听事件的
      var unloadPromises = appsToUnload.map(toUnloadPromise);
      var unmountUnloadPromises = appsToUnmount
        .map(toUnmountPromise)
        .map(function (unmountPromise) {
          return unmountPromise.then(toUnloadPromise);
        });
      var allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);
      var unmountAllPromise = Promise.all(allUnmountPromises);
      unmountAllPromise.then(function () {
        window.dispatchEvent(
          new customEvent(
            "single-spa:before-mount-routing-event",
            getCustomEventDetail(true)
          )
        );
      });

      /* We load and bootstrap apps while other apps are unmounting, but we
       * wait to mount the app until all apps are finishing unmounting
       */
      var loadThenMountPromises = appsToLoad.map(function (app) {
          //加载应用
        return toLoadPromise(app).then(function (app) {
          return tryToBootstrapAndMount(app, unmountAllPromise);
        });
      });
  }
```

toLoadPromise方法,发现这边是个promise，promise里面是调用`app.loadPromise`的信息，`app.loadPromise`也是一个promise，这说明我们在调用注册微应用信息的方法时app 属性的值为promise，接下来看`app.loadApp`,loadApp就是传入的函数，`smellsLikeAPromise`也是验证``app.loadApp``的执行结果是否为promise，如果是promise则往下执行，可以看到这边返回的是`loadPromise`的执行结果。

必须说明的一点```app.loadApp```方法必须是umd格式的代码，如何将我们写的一段js代码打包成umd格式进行测试？

使用打包工具，我用的是roolup，使用方法，全局安装`rollup,npm i -g roolup `

然后使用命令`rollup mount.js --file bundle.js --format umd --name "myBundle"`

mount.js是我单独写的js文件为了方便打包，bundle.js是指定打包后的文件名， umd是指定打包格式， --name选项，导出的变量为myBundle

也可以[参考roolup官网](https://www.rollupjs.com/)

```js
function toLoadPromise(app) {
  return Promise.resolve().then(function () {
    if (app.loadPromise) {
      return app.loadPromise;
    }
    if (app.status !== NOT_LOADED && app.status !== LOAD_ERROR) {
      return app;
    }
    app.status = LOADING_SOURCE_CODE;
    var appOpts, isUserErr;
      //app.loadPromise -> registerApplication中app属性的值为一个异步函数
    return (app.loadPromise = Promise.resolve()
      .then(function () {
        //此处的app.loadApp就相当于见下面一段代码   loadPromise ->  return new Promise(xxx)应用打包结果需要封装为一个promise
        var loadPromise = app.loadApp(getProps(app));
         //验证加载微应用代码的函数是否为promise
        if (!smellsLikeAPromise(loadPromise)) {}
        return loadPromise.then(function (val) {
          app.loadErrorTime = null;
          appOpts = val;
          var validationErrMessage, validationErrCode;
			//...省略一些验证信息
          app.status = NOT_BOOTSTRAPPED;
          app.bootstrap = flattenFnArray(appOpts, "bootstrap");
          app.mount = flattenFnArray(appOpts, "mount");
          app.unmount = flattenFnArray(appOpts, "unmount");
          app.unload = flattenFnArray(appOpts, "unload");
          app.timeouts = ensureValidAppTimeouts(appOpts.timeouts);
          delete app.loadPromise;
          return app;
        });
      })
  });
}
```

其实加载的流程就是根据`registerApplication`的传参，执行`app`属性里面的代码，只不过在`single-spa`中里面的这部分代码乾坤已经帮我们封装了，我们只需要传入`entry`和应用访问地址，`qiankun`会使用`import-html-entry`会根据我们传的`entry`，解析出模板信息，css信息和script信息（这部分就不过多说了，之前有写过乾坤资源加载机制的文章，可以[参考这篇文章](https://www.jianshu.com/p/e08c049c69e7)），然后我们又使用打包工具`webpack`将其打包格式配置为`umd`格式帮我们做手动打包这部分工作。

在子系统接入微应用时我们需要在子应用中声明几个生命周期函数，qiankun就通过控制声明周期函数来控制微应用的挂载和卸载以此达到子应用切换的目的。

在single-spa内部发现并非有很多的逻辑代码，都是promise，通过注册的app，对其进行管理和控制。

```js
registerApplication({
  name: "appVue2",
  app: async () => {
      //app.loadApp执行的实际就是该段代码，必须返回是umd格式的会有校验，否则会提示报错
    return new Promise((resolve, reject) => {
      (function (factory) {
        typeof define === "function" && define.amd
          ? define(factory)
          : factory();
      })(function () {
        "use strict";

        function load() {
          return new Promise((resolve, reject) => {
            resolve({
              async mount() {
                console.log("load mount");
              },
              async bootstrap() {
                console.log("load bootstrap");
              },
            });
          });
        }

        load();
      });
    });
  },
  activeWhen: (location) => location.pathname.startsWith("/app-vue2"),
});
```

#### reroute

reroute 方法，没有开启时进行加载app，调用loadApps方法，loadApps中准备加载应用，准备完毕后注册自定义事件`callAllEventListeners`

```js
function reroute() {
      if (isStarted()) {
        appChangeUnderway = true;
        appsThatChanged = appsToUnload.concat(
          appsToLoad,
          appsToUnmount,
          appsToMount
        );
        return performAppChanges();
      } else {
        appsThatChanged = appsToLoad;
        return loadApps();
      }
      function loadApps() {
        return Promise.resolve().then(function () {
          var loadPromises = appsToLoad.map(toLoadPromise);
          return (
            Promise.all(loadPromises)
              .then(callAllEventListeners)
              .then(function () {
                return [];
              })
              .catch(function (err) {
                callAllEventListeners();
                throw err;
              })
          );
        });
      }
}
```

callAllEventListeners方法，遍历每个应用，给每个应用都添加callCapturedEventListeners事件监听，这边是操作的备份对象不会对浏览器中的事件进行重写。

```js
  function callAllEventListeners() {
    pendingPromises.forEach(function (pendingPromise) {
      callCapturedEventListeners(pendingPromise.eventArguments);
    });
    callCapturedEventListeners(eventArguments);
  }
```

callCapturedEventListeners方法，遍历快照中重写的方法，之后监听到"hashchange", "popstate"时就会走我们自己定义的方法逻辑。

```js
var routingEventsListeningTo = ["hashchange", "popstate"];
function callCapturedEventListeners(eventArguments) {
  var _this = this;
  if (eventArguments) {
    var eventType = eventArguments[0].type;
    if (routingEventsListeningTo.indexOf(eventType) >= 0) {
      capturedEventListeners[eventType].forEach(function (listener) {
        try {
          // The error thrown by application event listener should not break single-spa down.
          // Just like https://github.com/single-spa/single-spa/blob/85f5042dff960e40936f3a5069d56fc9477fac04/src/navigation/reroute.js#L140-L146 did
          listener.apply(_this, eventArguments);
        } catch (e) {
          setTimeout(function () {
            throw e;
          });
        }
      });
    }
  }
}
```

这个流程完毕之后，主应用调用了start方法后，就开始走`performAppChanges`相关逻辑。上篇文章有讲到过，主要是通过控制状态来达到激活和切换子应用的效果。

路由切换的时候怎么进行微应用加载的？

实现原理：通过监听和重写浏览器的`hashchange `、`popstate `、`pushState `和`replaceState `的方法 

下面这段代码是默认执行的，说明一开始就对浏览器中的方法进行了注册和重写，`hash`模式的代码会重写`hashchange`方法，当使用`history`模式时，`pushState`和 `replaceState`事件被触发时不会触发  `popstate`事件，只有`back `、`forward `、`go `才可以触发。

[pushState](https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState)：只会向历史堆栈里面添加一个状态，不会更新页面，传了url不同源时会报错，不传则将其设置为当前文档的url。

[replaceState](https://developer.mozilla.org/zh-CN/docs/Web/API/History/replaceState)：修改当前历史记录实体 ，同上，传了url不同源时会报错，不传则将其设置为当前文档的url。

```js
//判断是否在浏览器环境
if (isInBrowser) {
  window.addEventListener("hashchange", urlReroute);
  window.addEventListener("popstate", urlReroute);

  // 不要直接操作原有方法，在copy的方法上操作
  var originalAddEventListener = window.addEventListener;
  var originalRemoveEventListener = window.removeEventListener;
//重写pushState方法
  window.history.pushState = patchedUpdateState(
    window.history.pushState,
    "pushState"
  );
    //重写replaceState方法
  window.history.replaceState = patchedUpdateState(
    window.history.replaceState,
    "replaceState"
  );
}
```

patchedUpdateState，记录跳转前和跳转后的url，如果`urlBefore`和`urlAfter`不同的时候才会重写路由，否则就只要进行`pushState `和`replaceState `操作就会调用。

只有子应用启动了之后才手动触发`popState`事件，因为在没有启动子应用之前就可以使用默认的路由事件了。

`dispatchEvent`即为派发事件，实际就是我们在开始时监听了`popstate`事件，回调函数即`reroute`，因此`pushstate`和`replacestate`执行`reroute`的本质上是通过`popstate`来触发`route`的

```js
function patchedUpdateState(updateState, methodName) {
  return function () {
      //性能优化，只有当当前页面和要跳转的页面不一样时才创建createPopStateEvent
      //获取跳转前的url
    var urlBefore = window.location.href;
    var result = updateState.apply(this, arguments);
      //获取跳转后的url
    var urlAfter = window.location.href;
    if (!urlRerouteOnly || urlBefore !== urlAfter) {
      if (isStarted()) {
        window.dispatchEvent(
          createPopStateEvent(window.history.state, methodName)
        );
      } else {
        reroute([]);
      }
    }
    return result;
  };
}
```

createPopStateEvent方法，将重写后的popstate返回

```js
function createPopStateEvent(state, originalMethodName) {
  var evt;
  try {
    evt = new PopStateEvent("popstate", {
      state: state,
    });
  } catch (err) {
    evt = document.createEvent("PopStateEvent");
    evt.initPopStateEvent("popstate", false, false, state);
  }
  evt.singleSpa = true;
  evt.singleSpaTrigger = originalMethodName;
  return evt;
}
```

为什么要重写`pushState`和 `replaceState`方法？

[这篇文章对这个问题的解释我觉得是最合理的](https://segmentfault.com/a/1190000042798993)

除了在微前端框架中需要监听对应的导航事件外，在微前端框架外部我们也可以通过 `addEventListener` 的方式来注册 `hashchange` 和 `popstate` 事件，那么这样一来导航事件就会有多个，为了在实现对导航事件的控制，达到路由变化时对应的子应用能够正确的 **卸载** 和 **挂载**，需要对 `addEventListener` 注册的 `hashchange` 和 `popstate` 进行拦截，并将对应的事件给存储起来，便于后续在特定的时候能够实现手动触发。 

发现在挂载和卸载阶段都调用了`callAllEventListeners `方法，而`callAllEventListeners `又调用了`callCapturedEventListeners `方法，`callCapturedEventListeners`方法中是对"hashchange", "popstate"挨个进行手动调用。

`callCapturedEventListeners`方法源码参考上面













乾坤框架系列学习
[01.学习微前端架构-乾坤](https://www.jianshu.com/p/b42a93b58eec)
[[02.资源加载过程分析](https://www.jianshu.com/p/e08c049c69e7?v=1667894368589)](https://www.jianshu.com/p/e08c049c69e7?v=1667894368589)
[03.乾坤css加载机制](https://www.jianshu.com/p/67585c603dd2)
[04.乾坤js隔离机制](https://www.jianshu.com/p/86eb23a31656)
[乾坤沙箱实现原理](https://www.jianshu.com/p/5bd2f4c4524b)







调试方法：

* 学习的方法，可以把源码的内容拷贝过来，自己启动一个项目，使用模块依赖的方式进行debug，会比自己单看源码清晰的多，并且也可以清晰的看到执行结果和执行过程。
* 下载源码后，使用npm link，debug到源码进行调试



vue3的代码设置跨域

一直不停在加载问题





网点组可以添加多个吗

只有一个的时候怎么关联网点组？

查看网点和查看客户信息是从哪儿进去的？

基础价格配置从哪儿点进去报价组编辑的？

网点分组页面？

固定+浮动报价设置只展示一个报价吗还是



[样式隔离](https://qiankun.umijs.org/zh/api#registermicroappsapps-lifecycles)

网点管理页面



关联网点只能关联没有设置的网点







